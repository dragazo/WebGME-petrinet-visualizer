/*globals define, WebGMEGlobal*/

/**
 * Generated by VisualizerGenerator 1.7.0 from webgme on Thu Nov 12 2020 22:52:52 GMT-0600 (Central Standard Time).
 */

const PLACE_TYPE = 'Place';
const TRANS_TYPE = 'Transition';
const ARC_TYPE = 'Arc';

const ANIMATION_TIME = 500;

const markStrings = [
    '',
    '⬤',
    '⬤⬤',
    '⬤⬤⬤',
    '⬤⬤⬤⬤',
    '⬤⬤⬤⬤\n⬤',
    '⬤⬤⬤⬤\n⬤⬤',
    '⬤⬤⬤⬤\n⬤⬤⬤',
    '⬤⬤⬤⬤\n⬤⬤⬤⬤',
    '⬤⬤⬤⬤\n⬤⬤⬤⬤\n⬤',
    '⬤⬤⬤⬤\n⬤⬤⬤⬤\n⬤⬤',
    '⬤⬤⬤⬤\n⬤⬤⬤⬤\n⬤⬤⬤',
    '⬤⬤⬤⬤\n⬤⬤⬤⬤\n⬤⬤⬤⬤',
];
function getMarkString(count) {
    if (count < 0 || count > 12) return count.toString();
    return markStrings[count];
}
function getMarks(place) {
    return place.attr('marks');
}
function updateMarks(place, count) {
    place.attr('marks', count);
    place.attr('label/text', getMarkString(count));
}

define(['jointjs', 'css!./styles/petrivizWidget.css', 'css!jointjscss'], function (jointjs) {
    'use strict';

    var WIDGET_CLASS = 'petriviz';

    function petrivizWidget(logger, container, client) {
        this._logger = logger.fork('Widget');

        this._el = container;
        this._client = client;

        this._places = {};
        this._transitions = {};
        this._arcs = {};
        this._missingArcs = {};

        this._initialize();

        this._logger.debug('ctor finished');
    }

    petrivizWidget.prototype._initialize = function () {
        const width = this._el.width(),
            height = this._el.height(),
            self = this;

        // set widget class
        this._el.addClass(WIDGET_CLASS);

        this._graph = new jointjs.dia.Graph;
        this._paper = new jointjs.dia.Paper({
            el: $(this._el),
            width, height,
            gridSize: 1,
            defaultAnchor: { name: 'perpendicular' },
            defaultConnectionPoint: { name: 'boundary' },
            model: this._graph,
        });

        this._paper.setInteractivity(false);
        this._paper.removeTools();

        this._paper.on('element:pointerclick', function(view) {
            const elem = view.model;
            const trans = self.getTransitionWithCID(elem.cid);
            if (trans !== undefined) {
                if (self.isTransitionEnabled(trans)) self.fireTransition(trans);
            }
        });
        this._paper.on('element:mousewheel', function(view, evt, x, y, delta) {
            const elem = view.model;
            const place = self.getPlaceWithCID(elem.cid);
            if (place !== undefined) {
                if (delta != 0) { // probably always true, but just to be safe
                    const marks = getMarks(place.simnode);
                    updateMarks(place.simnode, delta > 0 ? marks + 1 : marks - 1);
                    self.updateAllTransColors(); // update after changing count
                }
            }
        });

        this._place = jointjs.dia.Element.define('network.Place', {
            attrs: {
                circle: {
                    r: 35,
                    'stroke-width': 3,
                    stroke: '#000000',
                    fill: '#ffffff',
                    cursor: 'pointer',
                },
                text: {
                    'font-weight': '800',
                    'text-anchor': 'middle',
                    'ref-x': 0.5,
                    'ref-y': -20,
                    'ref': 'circle',
                    cursor: 'pointer',
                },
                label: {
                    'font-weight': '400',
                    'text-anchor': 'middle',
                    'ref-y': 20,
                    'ref': 'circle',
                    cursor: 'pointer',
                },
                marks: 0,
            },
        }, {
            markup: [
                { tagName: 'circle', selector: 'circle' },
                { tagName: 'text', selector: 'text' },
                { tagName: 'text', selector: 'label' },
            ],
        });

        // // Create a dummy header
        // this._el.append('<h3>petriviz Events:</h3>');

        // // Registering to events can be done with jQuery (as normal)
        // this._el.on('dblclick', function (event) {
        //     event.stopPropagation();
        //     event.preventDefault();
        //     self.onBackgroundDblClick();
        // });
    };

    petrivizWidget.prototype.onWidgetContainerResize = function (width, height) {
        this._logger.debug('Widget is resizing...');
        if (this._paper) {
            this._paper.setDimensions(width, height);
            this._paper.scaleContentToFit();
        }
    };

    petrivizWidget.prototype.resetMarkings = function() {
        for (const place of Object.values(this._places)) {
            updateMarks(place.simnode, place.gmenode.getAttribute('initMarking'));
        }
        this.updateAllTransColors();
    };

    petrivizWidget.prototype.getFreeChoiceCounterexample = function () {
        const trans = Object.values(this._transitions);
        for (let i = 0; i < trans.length; ++i) {
            for (let j = i + 1; j < trans.length; ++j) {
                const a = this.getInplaces(trans[i]);
                const b = this.getInplaces(trans[j]);
                for (const x of a) {
                    for (const y of b) {
                        if (x.place.id === y.place.id) return [trans[i], trans[j]];
                    }
                }
            }
        }
        return null;
    };
    petrivizWidget.prototype._get1To1InOut = function (group) {
        for (const p of Object.values(group)) {
            const a = this.getInplaces(p);
            if (a.length !== 1) return [p, a.length, 'in'];

            const b = this.getOutplaces(p);
            if (b.length !== 1) return [p, b.length, 'out'];
        }
        return null;
    };
    petrivizWidget.prototype.getStateMachineCounterexample = function () {
        return this._get1To1InOut(this._transitions);
    };
    petrivizWidget.prototype.getMarkedGraphCounterexample = function () {
        return this._get1To1InOut(this._places);
    };
    petrivizWidget.prototype.getWorkflowCounterexample = function () {
        const sources = this.getSourcePlaces();
        if (sources.length !== 1) return ['source', sources];
        const sinks = this.getSinkPlaces();
        if (sinks.length !== 1) return ['sink', sinks];
        
        const source = sources[0];
        const sink = sinks[0];
        const nodes = Object.values(this._places).concat(Object.values(this._transitions));
        for (const x of nodes) {
            if (!this.pathExists(source, x) || !this.pathExists(x, sink)) return ['reach', source, x, sink];
        }

        return null;
    };
    petrivizWidget.prototype.getClassifyString = function() {
        let res = '';

        const formatNode = n => `${n.simnode.attr('.label/text')} (${n.id})`;

        let counter = this.getFreeChoiceCounterexample();
        if (!counter) res += 'Free Choice\n';
        else res += `Not Free Choice: transitions '${formatNode(counter[0])} and '${formatNode(counter[1])}) have common inplaces\n`;

        counter = this.getStateMachineCounterexample();
        if (!counter) res += 'State Machine\n';
        else res += `Not State Machine: transition '${formatNode(counter[0])}) has ${counter[1]} ${counter[2]}places\n`;

        counter = this.getMarkedGraphCounterexample();
        if (!counter) res += 'Marked Graph\n';
        else res += `Not Marked Graph: place '${formatNode(counter[0])}) has ${counter[1]} ${counter[2]} transitions\n`;

        counter = this.getWorkflowCounterexample();
        if (!counter) res += 'Workflow Graph\n';
        else if (counter[0] === 'source') res += `Not Workflow Graph: graph has '${counter[1].length}' sources\n`;
        else if (counter[0] === 'sink') res += `Not Workflow Graph: graph has '${counter[1].length}' sinks\n`;
        else if (counter[0] === 'reach') res += `Not Workflow Graph: no path from source ${formatNode(counter[1])} to sink ${formatNode(counter[3])} containing ${formatNode(counter[2])}\n`;
        else res += 'Not Workflow Graph'; // should never happen unless impl changes

        return res;
    };

    /// returns true if `from === to` or if there is a (directed) path `from -> to`
    petrivizWidget.prototype.pathExists = function (from, to) {
        const visited = new Set();
        const queue = [from];
        while (queue.length > 0) {
            const p = queue[0];
            if (p === to) return true;
            delete queue[0];
            visited.add(p);

            for (const entry of this.getOutplaces(p)) {
                const next = entry.place;
                if (!visited.has(next) && !queue.includes(next)) queue.push(next);
            }
        }

        return false;
    };

    petrivizWidget.prototype.getSourcePlaces = function() {
        const res = [];
        for (const p of Object.values(this._places)) {
            if (this.getInplaces(p).length === 0) res.push(p);
        }
        return res;
    };
    petrivizWidget.prototype.getSinkPlaces = function() {
        const res = [];
        for (const p of Object.values(this._places)) {
            if (this.getOutplaces(p).length === 0) res.push(p);
        }
        return res;
    };

    petrivizWidget.prototype.getInplaces = function(trans) {
        const res = [];
        for (const arc of Object.values(this._arcs)) {
            if (arc.dst == trans) res.push({ place: arc.src, arc });
        }
        return res;
    };
    petrivizWidget.prototype.getOutplaces = function(trans) {
        const res = [];
        for (const arc of Object.values(this._arcs)) {
            if (arc.src == trans) res.push({ place: arc.dst, arc });
        }
        return res;
    };

    petrivizWidget.prototype.updateTransColor = function(trans) {
        const color = this.isTransitionEnabled(trans) ? '#00aacc' : '#000000';
        trans.simnode.attr('.root/fill', color);
    };
    petrivizWidget.prototype.updateAllTransColors = function() {
        for (const trans of Object.values(this._transitions)) this.updateTransColor(trans);
    }

    petrivizWidget.prototype.isTransitionEnabled = function(trans) {
        const inplaces = this.getInplaces(trans);
        for (const p of inplaces) {
            if (getMarks(p.place.simnode) <= 0) return false;
        }
        return true;
    };
    petrivizWidget.prototype.fireTransition = function(trans) {
        const inplaces = this.getInplaces(trans);
        const outplaces = this.getOutplaces(trans);
        if (inplaces.length !== 0) {
            for (const p of inplaces) {
                updateMarks(p.place.simnode, getMarks(p.place.simnode) - 1);
            }
            this.updateAllTransColors(); // update colors after decrementing everything (all done now)
            const last = inplaces.pop();
            for (const p of inplaces) {
                p.arc.simnode.findView(this._paper).sendToken(jointjs.V('circle', { r: 5, fill: '#3ae014' }), ANIMATION_TIME);
            }
            last.arc.simnode.findView(this._paper).sendToken(jointjs.V('circle', { r: 5, fill: '#3ae014' }), ANIMATION_TIME, () => {
                if (outplaces.length !== 0) {
                    for (const p of outplaces) {
                        p.arc.simnode.findView(this._paper).sendToken(jointjs.V('circle', { r: 5, fill: '#3ae014' }), ANIMATION_TIME, () => {
                            updateMarks(p.place.simnode, getMarks(p.place.simnode) + 1);
                            this.updateAllTransColors(); // update colors after incrementing each (some might still be running)
                        });
                    }
                }
            });
        }
    };

    petrivizWidget.prototype.getPlaceWithCID = function(cid) {
        for (const place of Object.values(this._places)) {
            if (place.simnode.cid === cid) return place;
        }
        return undefined;
    };
    petrivizWidget.prototype.getTransitionWithCID = function(cid) {
        for (const trans of Object.values(this._transitions)) {
            if (trans.simnode.cid === cid) return trans;
        }
        return undefined;
    };

    petrivizWidget.prototype.getPlaceOrTrans = function(id) {
        if (id in this._places) return this._places[id];
        if (id in this._transitions) return this._transitions[id];
        return undefined;
    };
    petrivizWidget.prototype.addMissingArcs = function () {
        const resolved = [];
        for (const key of Object.keys(this._missingArcs)) {
            const value = this._missingArcs[key];
            const src = this.getPlaceOrTrans(value.src);
            const dst = this.getPlaceOrTrans(value.dst);
            if (src !== undefined && dst !== undefined) {
                resolved.push(key);
                let redundant = false;
                for (const other of Object.values(this._arcs)) {
                    if (other.src === src && other.dst === dst) {
                        redundant = true;
                        break;
                    }
                }
                if (redundant) continue; // user should not put redundant arcs, but if present it is equivalent to having only one arc

                const arc = new jointjs.shapes.standard.Link();
                arc.source(src.simnode, { anchor: { name: 'center' } });
                arc.target(dst.simnode, { anchor: { name: 'center' } });
                this._graph.addCell([arc]);
                this._arcs[key] = {
                    id: key,
                    src, dst,
                    simnode: arc,
                    gmenode: value.gmenode,
                };
            }
        }
        for (const key of resolved) {
            delete this._missingArcs[key];
        }
    };
    petrivizWidget.prototype.addNode = function (desc) {
        const node = this._client.getNode(desc.id);
        if (node.isInstanceOf(PLACE_TYPE)) {
            const position = node.getRegistry('position');
            const place = new this._place({
                position,
                attrs: {
                    text: { text: node.getAttribute('name') },
                },
            });
            updateMarks(place, node.getAttribute('initMarking'));
            this._graph.addCell([place]);
            this._places[desc.id] = {
                id: desc.id,
                simnode: place,
                gmenode: node,
            };
            this.addMissingArcs();
            this.updateAllTransColors();
        }
        else if (node.isInstanceOf(TRANS_TYPE)) {
            const position = node.getRegistry('position');
            const trans = new jointjs.shapes.pn.Transition({
                position: { x: position.x - 5, y: position.y - 23 },
                attrs: {
                    '.label': { text: node.getAttribute('name'), fill: '#000000' },
                    '.root': { fill: '#000000', stroke: '#000000' },
                },
            });
            this._graph.addCell([trans]);
            this._transitions[desc.id] = {
                id: desc.id,
                simnode: trans,
                gmenode: node,
            };
            this.addMissingArcs();
            this.updateAllTransColors();
        }
        else if (node.isInstanceOf(ARC_TYPE)) {
            const src = node.getPointerId('src');
            const dst = node.getPointerId('dst');
            this._missingArcs[desc.id] = {
                src, dst,
                gmenode: node,
            };
            this.addMissingArcs();
            this.updateAllTransColors();
        }




        // if (desc) {
        //     // Add node to a table of nodes
        //     var node = document.createElement('div'),
        //         label = 'children';

        //     if (desc.childrenIds.length === 1) {
        //         label = 'child';
        //     }

        //     this.nodes[desc.id] = desc;
        //     node.innerHTML = 'Adding node "' + desc.name + '" (click to view). It has ' +
        //         desc.childrenIds.length + ' ' + label + '.';

        //     this._el.append(node);
        //     node.onclick = this.onNodeClick.bind(this, desc.id);
        // }
    };

    petrivizWidget.prototype.removeNode = function (gmeId) {
        // var desc = this.nodes[gmeId];
        // this._el.append('<div>Removing node "' + desc.name + '"</div>');
        // delete this.nodes[gmeId];
    };

    petrivizWidget.prototype.updateNode = function (desc) {
        // if (desc) {
        //     this._logger.debug('Updating node:', desc);
        //     this._el.append('<div>Updating node "' + desc.name + '"</div>');
        // }
    };

    // actual simulator functions
    petrivizWidget.prototype.initNetwork = function (descriptor) {
        const pn = jointjs.shapes.pn;

        const place1 = new this._place({
            position: { x: 200, y: 100 },
            attrs: {
                text: { text: 'ready' },
                label: { text: 'other' },
            },
        });
        const place2 = new this._place({
            position: { x: 200, y: 300 },
            attrs: {
                text: { text: 'whatever' },
                label: { text: 'other' },
            },
        });
        const transition1 = new pn.Transition({
            position: { x: 50, y: 200 },
            attrs: {
                '.label': {
                    text: 'produce',
                    fill: '#fe854f',
                },
                '.root': {
                    fill: '#9586fd',
                    stroke: '#9586fd',
                },
            },
        });
        // const link1 = new pn.Link({
        //     source: { id: place1.id, selector: '.root' },
        //     target: { id: transition1.id, selector: '.root' },
        //     attrs: {
        //         '.connection': {
        //             fill: 'none',
        //             'stroke-linejoin': 'round',
        //             'stroke-width': '2',
        //             stroke: '#4b4a67',
        //         },
        //     },
        // });
        const link2 = new jointjs.shapes.standard.Link();
        link2.source(place1);
        link2.target(transition1);

        this._graph.addCell([place1, transition1, link2, place2]);

        setTimeout(() => {
            link2.findView(this._paper).sendToken(jointjs.V('circle', { r: 5, fill: '#feb662' }),
                500, () => { console.log('token sent'); place2.attr('label/text', '1'); });
        }, 1000);
    };

    // click handling
    petrivizWidget.prototype.onElementClick = function (elementView, event) {
        event.stopPropagation();
        console.log(elementView);
    };

    /* * * * * * * * Visualizer event handlers * * * * * * * */

    // petrivizWidget.prototype.onNodeClick = function (/*id*/) {
    //     // This currently changes the active node to the given id and
    //     // this is overridden in the controller.
    // };

    // petrivizWidget.prototype.onBackgroundDblClick = function () {
    //     this._el.append('<div>Background was double-clicked!!</div>');
    // };

    /* * * * * * * * Visualizer life cycle callbacks * * * * * * * */
    petrivizWidget.prototype.destroy = function () {
    };

    petrivizWidget.prototype.onActivate = function () {
        this._logger.debug('petrivizWidget has been activated');
    };

    petrivizWidget.prototype.onDeactivate = function () {
        this._logger.debug('petrivizWidget has been deactivated');
    };

    return petrivizWidget;
});
